var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getAugmentedNamespace(n) {
  var f = n.default;
	if (typeof f == "function") {
		var a = function () {
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

const URL$1 = globalThis.URL;

const REGEX_HTTP_PROTOCOL = /^https?:\/\//i;

var lightweight = url => {
  try {
    const { href } = new URL$1(url);
    return REGEX_HTTP_PROTOCOL.test(href) && href
  } catch (err) {
    return false
  }
};

var dist = {};

function iter(output, nullish, sep, val, key) {
	var k, pfx = key ? (key + sep) : key;

	if (val == null) {
		if (nullish) output[key] = val;
	} else if (typeof val != 'object') {
		output[key] = val;
	} else if (Array.isArray(val)) {
		for (k=0; k < val.length; k++) {
			iter(output, nullish, sep, val[k], pfx + k);
		}
	} else {
		for (k in val) {
			iter(output, nullish, sep, val[k], pfx + k);
		}
	}
}

function flattie(input, glue, toNull) {
	var output = {};
	if (typeof input == 'object') {
		iter(output, !!toNull, glue || '.', input, '');
	}
	return output;
}

dist.flattie = flattie;

function encode(obj, pfx) {
	var k, i, tmp, str='';

	for (k in obj) {
		if ((tmp = obj[k]) !== void 0) {
			if (Array.isArray(tmp)) {
				for (i=0; i < tmp.length; i++) {
					str && (str += '&');
					str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp[i]);
				}
			} else {
				str && (str += '&');
				str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp);
			}
		}
	}

	return (pfx || '') + str;
}

function toValue(mix) {
	if (!mix) return '';
	var str = decodeURIComponent(mix);
	if (str === 'false') return false;
	if (str === 'true') return true;
	return (+str * 0 === 0) ? (+str) : str;
}

function decode(str) {
	var tmp, k, out={}, arr=str.split('&');

	while (tmp = arr.shift()) {
		tmp = tmp.split('=');
		k = tmp.shift();
		if (out[k] !== void 0) {
			out[k] = [].concat(out[k], toValue(tmp.shift()));
		} else {
			out[k] = toValue(tmp.shift());
		}
	}

	return out;
}

var qss_m = /*#__PURE__*/Object.freeze({
	__proto__: null,
	encode: encode,
	decode: decode
});

var require$$2 = /*@__PURE__*/getAugmentedNamespace(qss_m);

const ENDPOINT = {
  FREE: 'https://api.microlink.io',
  PRO: 'https://pro.microlink.io'
};

const isObject = input => input !== null && typeof input === 'object';

const isBuffer = input =>
  input != null &&
  input.constructor != null &&
  typeof input.constructor.isBuffer === 'function' &&
  input.constructor.isBuffer(input);

const parseBody = (input, error, url) => {
  try {
    return JSON.parse(input)
  } catch (_) {
    const message = input || error.message;

    return {
      status: 'error',
      data: { url: message },
      more: 'https://microlink.io/efatalclient',
      code: 'EFATALCLIENT',
      message,
      url
    }
  }
};

const factory$1 = ({
  VERSION,
  MicrolinkError,
  urlHttp,
  stringify,
  got,
  flatten
}) => {
  const assertUrl = (url = '') => {
    if (!urlHttp(url)) {
      const message = `The \`url\` as \`${url}\` is not valid. Ensure it has protocol (http or https) and hostname.`;
      throw new MicrolinkError({
        status: 'fail',
        data: { url: message },
        more: 'https://microlink.io/docs/api/api-parameters/url',
        code: 'EINVALURLCLIENT',
        message,
        url
      })
    }
  };

  const mapRules = rules => {
    if (!isObject(rules)) return
    const flatRules = flatten(rules);
    return Object.keys(flatRules).reduce((acc, key) => {
      acc[`data.${key}`] = flatRules[key].toString();
      return acc
    }, {})
  };

  const fetchFromApi = async (apiUrl, opts = {}, retryCount = 0) => {
    try {
      const response = await got(apiUrl, opts);
      return opts.responseType === 'buffer'
        ? { body: response.body, response }
        : { ...response.body, response }
    } catch (err) {
      const { response = {} } = err;
      const {
        statusCode,
        body: rawBody,
        headers = {},
        url: uri = apiUrl
      } = response;
      const isBodyBuffer = isBuffer(rawBody);

      const body =
        isObject(rawBody) && !isBodyBuffer
          ? rawBody
          : parseBody(isBodyBuffer ? rawBody.toString() : rawBody, err, uri);

      if (body.code === 'EFATALCLIENT' && retryCount++ < 2) {
        return fetchFromApi(apiUrl, opts, retryCount)
      }

      throw new MicrolinkError({
        ...body,
        message: body.message,
        url: uri,
        statusCode,
        headers
      })
    }
  };

  const getApiUrl = (
    url,
    { data, apiKey, endpoint, retry, cache, ...opts } = {},
    { responseType = 'json', headers: gotHeaders, ...gotOpts } = {}
  ) => {
    const isPro = !!apiKey;
    const apiEndpoint = endpoint || ENDPOINT[isPro ? 'PRO' : 'FREE'];

    const apiUrl = `${apiEndpoint}?${stringify({
      url,
      ...mapRules(data),
      ...flatten(opts)
    })}`;

    const headers = isPro
      ? { ...gotHeaders, 'x-api-key': apiKey }
      : { ...gotHeaders };
    return [apiUrl, { ...gotOpts, responseType, cache, retry, headers }]
  };

  const createMql = defaultOpts => async (url, opts, gotOpts) => {
    assertUrl(url);
    const [apiUrl, fetchOpts] = getApiUrl(url, opts, {
      ...defaultOpts,
      ...gotOpts
    });
    return fetchFromApi(apiUrl, fetchOpts)
  };

  const mql = createMql();
  mql.MicrolinkError = MicrolinkError;
  mql.getApiUrl = getApiUrl;
  mql.fetchFromApi = fetchFromApi;
  mql.mapRules = mapRules;
  mql.version = VERSION;
  mql.stream = got.stream;
  mql.buffer = createMql({ responseType: 'buffer' });

  return mql
};

var factory_1 = factory$1;

var ky$1 = {exports: {}};

(function (module, exports) {
	(function (global, factory) {
	    factory(exports) ;
	})(commonjsGlobal, (function (exports) {
	    // eslint-lint-disable-next-line @typescript-eslint/naming-convention
	    class HTTPError extends Error {
	        constructor(response, request, options) {
	            const code = (response.status || response.status === 0) ? response.status : '';
	            const title = response.statusText || '';
	            const status = `${code} ${title}`.trim();
	            const reason = status ? `status code ${status}` : 'an unknown error';
	            super(`Request failed with ${reason}`);
	            this.name = 'HTTPError';
	            this.response = response;
	            this.request = request;
	            this.options = options;
	        }
	    }

	    class TimeoutError extends Error {
	        constructor(request) {
	            super('Request timed out');
	            this.name = 'TimeoutError';
	            this.request = request;
	        }
	    }

	    // eslint-disable-next-line @typescript-eslint/ban-types
	    const isObject = (value) => value !== null && typeof value === 'object';

	    const validateAndMerge = (...sources) => {
	        for (const source of sources) {
	            if ((!isObject(source) || Array.isArray(source)) && typeof source !== 'undefined') {
	                throw new TypeError('The `options` argument must be an object');
	            }
	        }
	        return deepMerge({}, ...sources);
	    };
	    const mergeHeaders = (source1 = {}, source2 = {}) => {
	        const result = new globalThis.Headers(source1);
	        const isHeadersInstance = source2 instanceof globalThis.Headers;
	        const source = new globalThis.Headers(source2);
	        for (const [key, value] of source.entries()) {
	            if ((isHeadersInstance && value === 'undefined') || value === undefined) {
	                result.delete(key);
	            }
	            else {
	                result.set(key, value);
	            }
	        }
	        return result;
	    };
	    // TODO: Make this strongly-typed (no `any`).
	    const deepMerge = (...sources) => {
	        let returnValue = {};
	        let headers = {};
	        for (const source of sources) {
	            if (Array.isArray(source)) {
	                if (!Array.isArray(returnValue)) {
	                    returnValue = [];
	                }
	                returnValue = [...returnValue, ...source];
	            }
	            else if (isObject(source)) {
	                for (let [key, value] of Object.entries(source)) {
	                    if (isObject(value) && key in returnValue) {
	                        value = deepMerge(returnValue[key], value);
	                    }
	                    returnValue = { ...returnValue, [key]: value };
	                }
	                if (isObject(source.headers)) {
	                    headers = mergeHeaders(headers, source.headers);
	                    returnValue.headers = headers;
	                }
	            }
	        }
	        return returnValue;
	    };

	    const supportsAbortController = typeof globalThis.AbortController === 'function';
	    const supportsStreams = typeof globalThis.ReadableStream === 'function';
	    const supportsFormData = typeof globalThis.FormData === 'function';
	    const requestMethods = ['get', 'post', 'put', 'patch', 'head', 'delete'];
	    const responseTypes = {
	        json: 'application/json',
	        text: 'text/*',
	        formData: 'multipart/form-data',
	        arrayBuffer: '*/*',
	        blob: '*/*',
	    };
	    // The maximum value of a 32bit int (see issue #117)
	    const maxSafeTimeout = 2147483647;
	    const stop = Symbol('stop');

	    const normalizeRequestMethod = (input) => requestMethods.includes(input) ? input.toUpperCase() : input;
	    const retryMethods = ['get', 'put', 'head', 'delete', 'options', 'trace'];
	    const retryStatusCodes = [408, 413, 429, 500, 502, 503, 504];
	    const retryAfterStatusCodes = [413, 429, 503];
	    const defaultRetryOptions = {
	        limit: 2,
	        methods: retryMethods,
	        statusCodes: retryStatusCodes,
	        afterStatusCodes: retryAfterStatusCodes,
	        maxRetryAfter: Number.POSITIVE_INFINITY,
	    };
	    const normalizeRetryOptions = (retry = {}) => {
	        if (typeof retry === 'number') {
	            return {
	                ...defaultRetryOptions,
	                limit: retry,
	            };
	        }
	        if (retry.methods && !Array.isArray(retry.methods)) {
	            throw new Error('retry.methods must be an array');
	        }
	        if (retry.statusCodes && !Array.isArray(retry.statusCodes)) {
	            throw new Error('retry.statusCodes must be an array');
	        }
	        return {
	            ...defaultRetryOptions,
	            ...retry,
	            afterStatusCodes: retryAfterStatusCodes,
	        };
	    };

	    // `Promise.race()` workaround (#91)
	    const timeout = async (request, abortController, options) => new Promise((resolve, reject) => {
	        const timeoutId = setTimeout(() => {
	            if (abortController) {
	                abortController.abort();
	            }
	            reject(new TimeoutError(request));
	        }, options.timeout);
	        void options
	            .fetch(request)
	            .then(resolve)
	            .catch(reject)
	            .then(() => {
	            clearTimeout(timeoutId);
	        });
	    });
	    const delay = async (ms) => new Promise(resolve => {
	        setTimeout(resolve, ms);
	    });

	    class Ky {
	        // eslint-disable-next-line complexity
	        constructor(input, options = {}) {
	            var _a, _b, _c;
	            this._retryCount = 0;
	            this._input = input;
	            this._options = {
	                // TODO: credentials can be removed when the spec change is implemented in all browsers. Context: https://www.chromestatus.com/feature/4539473312350208
	                credentials: this._input.credentials || 'same-origin',
	                ...options,
	                headers: mergeHeaders(this._input.headers, options.headers),
	                hooks: deepMerge({
	                    beforeRequest: [],
	                    beforeRetry: [],
	                    beforeError: [],
	                    afterResponse: [],
	                }, options.hooks),
	                method: normalizeRequestMethod((_a = options.method) !== null && _a !== void 0 ? _a : this._input.method),
	                // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
	                prefixUrl: String(options.prefixUrl || ''),
	                retry: normalizeRetryOptions(options.retry),
	                throwHttpErrors: options.throwHttpErrors !== false,
	                timeout: typeof options.timeout === 'undefined' ? 10000 : options.timeout,
	                fetch: (_b = options.fetch) !== null && _b !== void 0 ? _b : globalThis.fetch.bind(globalThis),
	            };
	            if (typeof this._input !== 'string' && !(this._input instanceof URL || this._input instanceof globalThis.Request)) {
	                throw new TypeError('`input` must be a string, URL, or Request');
	            }
	            if (this._options.prefixUrl && typeof this._input === 'string') {
	                if (this._input.startsWith('/')) {
	                    throw new Error('`input` must not begin with a slash when using `prefixUrl`');
	                }
	                if (!this._options.prefixUrl.endsWith('/')) {
	                    this._options.prefixUrl += '/';
	                }
	                this._input = this._options.prefixUrl + this._input;
	            }
	            if (supportsAbortController) {
	                this.abortController = new globalThis.AbortController();
	                if (this._options.signal) {
	                    this._options.signal.addEventListener('abort', () => {
	                        this.abortController.abort();
	                    });
	                }
	                this._options.signal = this.abortController.signal;
	            }
	            this.request = new globalThis.Request(this._input, this._options);
	            if (this._options.searchParams) {
	                // eslint-disable-next-line unicorn/prevent-abbreviations
	                const textSearchParams = typeof this._options.searchParams === 'string'
	                    ? this._options.searchParams.replace(/^\?/, '')
	                    : new URLSearchParams(this._options.searchParams).toString();
	                // eslint-disable-next-line unicorn/prevent-abbreviations
	                const searchParams = '?' + textSearchParams;
	                const url = this.request.url.replace(/(?:\?.*?)?(?=#|$)/, searchParams);
	                // To provide correct form boundary, Content-Type header should be deleted each time when new Request instantiated from another one
	                if (((supportsFormData && this._options.body instanceof globalThis.FormData)
	                    || this._options.body instanceof URLSearchParams) && !(this._options.headers && this._options.headers['content-type'])) {
	                    this.request.headers.delete('content-type');
	                }
	                this.request = new globalThis.Request(new globalThis.Request(url, this.request), this._options);
	            }
	            if (this._options.json !== undefined) {
	                this._options.body = JSON.stringify(this._options.json);
	                this.request.headers.set('content-type', (_c = this._options.headers.get('content-type')) !== null && _c !== void 0 ? _c : 'application/json');
	                this.request = new globalThis.Request(this.request, { body: this._options.body });
	            }
	        }
	        // eslint-disable-next-line @typescript-eslint/promise-function-async
	        static create(input, options) {
	            const ky = new Ky(input, options);
	            const fn = async () => {
	                if (ky._options.timeout > maxSafeTimeout) {
	                    throw new RangeError(`The \`timeout\` option cannot be greater than ${maxSafeTimeout}`);
	                }
	                // Delay the fetch so that body method shortcuts can set the Accept header
	                await Promise.resolve();
	                let response = await ky._fetch();
	                for (const hook of ky._options.hooks.afterResponse) {
	                    // eslint-disable-next-line no-await-in-loop
	                    const modifiedResponse = await hook(ky.request, ky._options, ky._decorateResponse(response.clone()));
	                    if (modifiedResponse instanceof globalThis.Response) {
	                        response = modifiedResponse;
	                    }
	                }
	                ky._decorateResponse(response);
	                if (!response.ok && ky._options.throwHttpErrors) {
	                    let error = new HTTPError(response, ky.request, ky._options);
	                    for (const hook of ky._options.hooks.beforeError) {
	                        // eslint-disable-next-line no-await-in-loop
	                        error = await hook(error);
	                    }
	                    throw error;
	                }
	                // If `onDownloadProgress` is passed, it uses the stream API internally
	                /* istanbul ignore next */
	                if (ky._options.onDownloadProgress) {
	                    if (typeof ky._options.onDownloadProgress !== 'function') {
	                        throw new TypeError('The `onDownloadProgress` option must be a function');
	                    }
	                    if (!supportsStreams) {
	                        throw new Error('Streams are not supported in your environment. `ReadableStream` is missing.');
	                    }
	                    return ky._stream(response.clone(), ky._options.onDownloadProgress);
	                }
	                return response;
	            };
	            const isRetriableMethod = ky._options.retry.methods.includes(ky.request.method.toLowerCase());
	            const result = (isRetriableMethod ? ky._retry(fn) : fn());
	            for (const [type, mimeType] of Object.entries(responseTypes)) {
	                result[type] = async () => {
	                    // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
	                    ky.request.headers.set('accept', ky.request.headers.get('accept') || mimeType);
	                    const awaitedResult = await result;
	                    const response = awaitedResult.clone();
	                    if (type === 'json') {
	                        if (response.status === 204) {
	                            return '';
	                        }
	                        if (options.parseJson) {
	                            return options.parseJson(await response.text());
	                        }
	                    }
	                    return response[type]();
	                };
	            }
	            return result;
	        }
	        _calculateRetryDelay(error) {
	            this._retryCount++;
	            if (this._retryCount < this._options.retry.limit && !(error instanceof TimeoutError)) {
	                if (error instanceof HTTPError) {
	                    if (!this._options.retry.statusCodes.includes(error.response.status)) {
	                        return 0;
	                    }
	                    const retryAfter = error.response.headers.get('Retry-After');
	                    if (retryAfter && this._options.retry.afterStatusCodes.includes(error.response.status)) {
	                        let after = Number(retryAfter);
	                        if (Number.isNaN(after)) {
	                            after = Date.parse(retryAfter) - Date.now();
	                        }
	                        else {
	                            after *= 1000;
	                        }
	                        if (typeof this._options.retry.maxRetryAfter !== 'undefined' && after > this._options.retry.maxRetryAfter) {
	                            return 0;
	                        }
	                        return after;
	                    }
	                    if (error.response.status === 413) {
	                        return 0;
	                    }
	                }
	                const BACKOFF_FACTOR = 0.3;
	                return BACKOFF_FACTOR * (2 ** (this._retryCount - 1)) * 1000;
	            }
	            return 0;
	        }
	        _decorateResponse(response) {
	            if (this._options.parseJson) {
	                response.json = async () => this._options.parseJson(await response.text());
	            }
	            return response;
	        }
	        async _retry(fn) {
	            try {
	                return await fn();
	                // eslint-disable-next-line @typescript-eslint/no-implicit-any-catch
	            }
	            catch (error) {
	                const ms = Math.min(this._calculateRetryDelay(error), maxSafeTimeout);
	                if (ms !== 0 && this._retryCount > 0) {
	                    await delay(ms);
	                    for (const hook of this._options.hooks.beforeRetry) {
	                        // eslint-disable-next-line no-await-in-loop
	                        const hookResult = await hook({
	                            request: this.request,
	                            options: this._options,
	                            error: error,
	                            retryCount: this._retryCount,
	                        });
	                        // If `stop` is returned from the hook, the retry process is stopped
	                        if (hookResult === stop) {
	                            return;
	                        }
	                    }
	                    return this._retry(fn);
	                }
	                throw error;
	            }
	        }
	        async _fetch() {
	            for (const hook of this._options.hooks.beforeRequest) {
	                // eslint-disable-next-line no-await-in-loop
	                const result = await hook(this.request, this._options);
	                if (result instanceof Request) {
	                    this.request = result;
	                    break;
	                }
	                if (result instanceof Response) {
	                    return result;
	                }
	            }
	            if (this._options.timeout === false) {
	                return this._options.fetch(this.request.clone());
	            }
	            return timeout(this.request.clone(), this.abortController, this._options);
	        }
	        /* istanbul ignore next */
	        _stream(response, onDownloadProgress) {
	            const totalBytes = Number(response.headers.get('content-length')) || 0;
	            let transferredBytes = 0;
	            return new globalThis.Response(new globalThis.ReadableStream({
	                async start(controller) {
	                    const reader = response.body.getReader();
	                    if (onDownloadProgress) {
	                        onDownloadProgress({ percent: 0, transferredBytes: 0, totalBytes }, new Uint8Array());
	                    }
	                    async function read() {
	                        const { done, value } = await reader.read();
	                        if (done) {
	                            controller.close();
	                            return;
	                        }
	                        if (onDownloadProgress) {
	                            transferredBytes += value.byteLength;
	                            const percent = totalBytes === 0 ? 0 : transferredBytes / totalBytes;
	                            onDownloadProgress({ percent, transferredBytes, totalBytes }, value);
	                        }
	                        controller.enqueue(value);
	                        await read();
	                    }
	                    await read();
	                },
	            }));
	        }
	    }

	    /*! MIT License © Sindre Sorhus */
	    const createInstance = (defaults) => {
	        // eslint-disable-next-line @typescript-eslint/promise-function-async
	        const ky = (input, options) => Ky.create(input, validateAndMerge(defaults, options));
	        for (const method of requestMethods) {
	            // eslint-disable-next-line @typescript-eslint/promise-function-async
	            ky[method] = (input, options) => Ky.create(input, validateAndMerge(defaults, options, { method }));
	        }
	        ky.create = (newDefaults) => createInstance(validateAndMerge(newDefaults));
	        ky.extend = (newDefaults) => createInstance(validateAndMerge(defaults, newDefaults));
	        ky.stop = stop;
	        return ky;
	    };
	    const ky = createInstance();

	    exports.HTTPError = HTTPError;
	    exports.TimeoutError = TimeoutError;
	    exports["default"] = ky;

	    Object.defineProperty(exports, '__esModule', { value: true });

	}));
} (ky$1, ky$1.exports));

const urlHttp = lightweight;
const { flattie: flatten } = dist;
const { encode: stringify } = require$$2;

const factory = factory_1;
const { default: ky } = ky$1.exports;

class MicrolinkError extends Error {
  constructor (props) {
    super();
    this.name = 'MicrolinkError';
    Object.assign(this, props);
    this.description = this.message;
    this.message = this.code
      ? `${this.code}, ${this.description}`
      : this.description;
  }
}

const got = async (url, opts) => {
  try {
    if (opts.timeout === undefined) opts.timeout = false;
    const response = await ky(url, opts);
    const body = await response.json();
    const { headers, status: statusCode } = response;
    return { url: response.url, body, headers, statusCode }
  } catch (err) {
    if (err.response) {
      const { response } = err;
      err.response = {
        ...response,
        headers: Array.from(response.headers.entries()).reduce(
          (acc, [key, value]) => {
            acc[key] = value;
            return acc
          },
          {}
        ),
        statusCode: response.status,
        body: await response.text()
      };
    }
    throw err
  }
};

var browser = factory({
  MicrolinkError,
  urlHttp,
  stringify,
  got,
  flatten,
  VERSION: '0.10.30'
});

export { browser as default };
//# sourceMappingURL=mql.mjs.map
